> 编程语言基础（C++、Java） + 算法题（中等难度） + 数据结构 （树、链表为主）+ 计算机网络（TCP/IP相关） + 操作系统（进程和线程、内存调度）+ 项目经历


# HTML

## 从地址栏输入URL开始到显示的过程


## div和span的区别
div是块级元素，占一行，会换行，可以通过width设置div的宽度
span是行内元素,所以不能用width设置span的宽度，实际宽度为内部文本宽度

## HTML5新增特性

1. 章节语意标签，比如：`<footer>` `<article>` 等，可以使我们创建更友好的页面结构，便于搜索引擎抓取；

 	* `header`: 表示一组引导性的帮助，可能包含**标题元素**，也可以包含其他元素，像logo、分节头部、搜索表单等
	* `footer`: **表示页脚。**一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。
	* `nav`: **导航栏。**描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表.
	* `section`: 表示文档中的一个**区域**（或节），比如，内容中的一个专题组，一般来说会有包含一个标题（heading)。
	* `aside`: 其通常表现为**侧边栏或者嵌入内容**。
2. 表单元素，属性，比如：number email autocomplete等，可以让我们规定表单元素的输入类型，长度，表单元素的行为；
3. 多媒体标签，比如： `<video>` `<audio>`。可以让我们定义多媒体文件的类型和行为；
4. 2D绘图，矢量图应用，`<canvas>` `<svg>` 标签可以让我们在网页上绘制复杂的图形和显示复杂的图形；
5. 拖拽事件，drag drop 事件可以让我们在网页上对元素进行拖放操作；
6. 离线数据的存储，localStorage sessionStorage可以让开发者根据用户行为在客户端缓存数据，提高网站性能和用户体验；
7. 获取当前用于的地理位置，geolocation 可以让我们不依赖客户端就可以获取用户位置；
8. Application Cache 可以让我们对Web应用进行缓存，离线时也可以访问，增加用户体验；
9. web worker 可以让我们脱离JavaScript是单线程的这个魔咒，而且web worker独立于其它的脚本不会影响页面性能；
10. 被动的获取服务端数据，EventSource 对象可以让我们的应用程序不主动发送HTTP 请求的情况下接收服务端推送的消息，并且做出响应；

## 客户端存储
### cookie

setCookie/getCookie，是一个key-value对，优点是兼容性好，缺点是操作繁琐、只能存储简单的数据、还会过期，而且容量有限，个数有限，会随着HTTP请求发送到服务器，存在安全隐患，站点设置httponly时，js就无法操作cookie了，禁用时可以使用http的get请求来模拟cookie。 `document.cookie`只能获得非httponly的cookie.

### webStorage

setItem/getItem，优点是使用简单方便，缺点是IE某些版本不支持，不能存储复杂的对象，必须先转化成JSON字符串，没有索引搜索效率高，只能同步读写操作，当写入的数据比较大时可能导致js引擎堵塞

### sessionStorage

用于本地存储一个会话中的数据，这些数据只有在同一个会话中的页面才能访问，并且当会话结束后数据会随之销毁，因此，不是一个持久化的本地存储，存储量很大（各浏览器要求不同）

### localStorage

用于本地持久化存储，除非用户主动删除数据，否则永远不会过期，单个域名存储量大，总体数量没有限制

### websql database

一个本地数据库，大大提高了web应用程序的性能，减轻了服务器的压力。存储的数据是SQL，本地存储使用的是key-value结构，性能上不如webstorage

### IndexedDB

基于javascript对象继承的数据库，支持事务以及同步/异步读写操作

var indexedDB = window.indexedDB || window.webkitIndexedDB || window.msIndexedDB || window.mozIndexedDB;
var request = indexedDB.open("MyTestDB");
request.onsuccess = function(event) {
    var db = event.result;
}
## cookie和session
### 什么是cookie

cookie分为二种：以文件方式存储在硬盘空间上的长期性的cookie以及停留在浏览器所占内存中的临时性的cookie。在浏览网站时，常会有提示，询问是否要记住登陆状态，这种情况下，登录时填写的信息会以文件的形式存放在客户端的硬盘上。在用户登陆后，session会在cookie端产生一个session_id，这个session_id是存在于浏览器所占用的内存中，关闭浏览器时会消失。而cookie采用的是客户端保持状态的方案，是一种客户端会话状态的存储机制，是服务器在本地机器上存储的小段文本或者内存中的一段数据，并随着每一个请求发送到同一个服务器。网络服务器使用HTTP头消息将cookie信息发送到客户端，在客户端，浏览器解析这些cookie并将他们保存成一个本地文件，他会自动为同一个服务器上的请求附上这些cookie。由于采用服务端保持状态的机制，客户端也需要保存一个标识，所以session机制借助于cookie来保存标识以解决HTTP协议无状态的缺陷。

### 什么是session

session是一种服务端信息管理机制，他把这些信息以文件的形式存放到服务器的硬盘空间上。当客户端向服务器发送请求时，要求服务器产生一个session，服务器端会首先检查下客户端的cookie中是否有session_id，是否已经过期。如果存在新鲜的session_id，服务端会根据这个值检索出session，否则重新创建一个session_id。这个值是一个加了密的字符串，同一客户端第二次session_start时，值会不一样。这个session_id是存在客户端的cookie里面的，如果客户禁止cookie，session依然可以用，只不过需要通过其他方式来获取session_id，使用HTTP的get请求直接放在url中或者post请求以表单的形式提交到服务器端，从而使服务器了解客户端的状态。

### cookie和session的区别
Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。

### session和cookie谁更安全

答案是session，首先，如果两者一样安全，那么两者就没有必要共存了，只要cookie就好，让客户端来分担服务端的负担即可；其次，session的session_id是存放在cookie中，要攻破session，需要首先攻破cookie，攻破cookie后，还要启动session，而session启动时间不一样时，session_id也不同，不仅如此，会话结束后，session也会随着消失。

#### Q1: cookie, sessionStorage, localStorage比较
1. cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据
2. 三者都是键值对的集合
3. 一般情况下浏览器端不会修改cookie，但会频繁操作两个storage
4. 如果保存了cookie的话，http请求中一定会带上（但是fetch默认是不带cookie的）；而两个storage可以由脚本选择性的提交
5. sessionStorage会在会话结束后销毁；而local的那个会永久保存直到覆盖。cookie会在过期时间之后销毁。
6. 安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验（其实任何payload和qs里的参数都要校验）。

![区别](images/区别.png)

#### Q2: 如何计算一个网站的localstorage大小？

chrome的localstorage采用的是UTF-16的编码，即小于65535用16bit(2B)来编码，超过65535用32bit(4B)编码

```js
Storage.prototype.size = function() {
  var str = JSON.stringify(this);
  var length = 0;
  for(let ch of str) {
    if(ch.codePointAt(0) > 65535) {
      length += 4;
    } else {
      length += 2;
    }
  }
  return [length, 'B'].join(' ');
}
```

HTML转义字符：

```
<  &lt;
>  &gt;
"  &quot;
空格  &nbsp;
```

# CSS

## 盒模型
 标准盒模型包括:margin, border, padding, content.
 
  `css`中有`box-sizing`属性：用于计算元素宽度和高度的CSS盒模型。
  `box-sizing: content-box`（默认值）: 
  
  * width = content-width
  * height = content-height.
  
  `box-sizing: border-box`: 

  * width = border+padding+content-width;
  * height = border+padding+content-height;

## 伪类与伪元素

双冒号(::)表示伪元素。CSS 伪元素允许向元素的某些部分设置样式。

单冒号表示伪类。伪类用于向某些选择器添加特殊的效果

![伪类和伪元素](images/伪类和伪元素.png)

**伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。**

## 清除浮动

如果是临近节点清楚浮动比较简单，`clear:both`.

如果是父元素中的子元素浮动，为了防止父元素高度collapse.

```js
father:bofore {
  display: table;
  content: "";
}

father:after {
  display: table;
  content: "";
  clear: both;
}
```

## CSS画三角形
```js

// 将上、左、右border设为透明，这样会出现一个梯形
border-color: transparent, transparent, black, transparent; 
// 然后将content的width设为0，消除掉梯形的上边，出现了三角形
width:0;
// 使用boder-width来放大缩小三角形
border-width: 10px 100px 150px 100px;
```

## CSS画平行四边形

### 利用 三角形+矩形+三角形 拼接而成

### 利用`transform: skew(...)`

```js
<style>
.city {
  display: inline-block;
  padding: 5px 20px;
  border: 1px solid #44a5fc;
  color: #333;
  transform: skew(-20deg);
}

.city div {
  transform: skew(20deg);
}
</style>

<div class="city">
  <div>上海</div>
</div>
```

## CSS实现一个0.5px的直线

## 元素居中

```js
//将display设为inline-block即可
 <i style="display: inline-block;content: ''; width:20px; height: 0.5px; background: #000;"></i>
```

### 水平垂直居中
```js
 // method 1
    .container {
        border: 1px solid #000;
        width: 300px;
        height: 300px;
        /*父容器position为relative*/
        position: relative;
    }
    .box {
        border: 1px solid #000;
        width: 50px;
        height: 50px;
        
        /*magic begin*/
        position: absolute;
        margin: auto;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        /*magic end*/
    }
```

```js
// method 2

#div2 {
    position  : absolute;
    top       : 50%;
    left      : 50%;
    transform : translate(-50%,-50%);
}
```

### 垂直居中

1. flex布局

```js
.container {
  display: flex;
  flex-direction: column;
  justify-content: center;
}

```

2. 行高（适用于单行元素）

```js
.container {
  height: 100px;
  line-height: 100px;
}
```

## CSS3

### flexible box
flex-direction, justify-content, align-items，flex-wrap（是否换行）
### gradients(渐变)
### transitions


# js

## String

* length
* charAt()
* concat()
* indexOf()
* match(): 正则匹配，返回数组
* repeat()
* replace(): 正则替换
* search(): 正则查找，同indexOf()
* slice()
* split(): 字符串->数组
* startsWith()
* substr(pos, length)
* substring(start, end)
* toLowerCase()
* trim()
* codePointAt(): 返回UTF-16编码的值，用于计算localstorage大小

## 数组

* length
* concat(): 合并数组，可以有多个参数
* join(): 数组->字符串， 字符串->数组： split()
* pop(): 删除最后一个元素
* shift(): 删除第一个元素
* push(): 末尾插入元素
* unshift(): 头部插入元素
* reverse(): 数组逆序
* slice(start, end): 返回一个[start,end)的新书组，原数组不变
* splice(start, deleteCount, item1, item2, ...)： 用于删除／添加元素
* sort()
	
### 迭代方法

* every(): 返回true／false
* filter()
* find()
* forEach()
* map()
* reduce()
* some()

### 判断是否是数组的方法
1. `instanceof`
2. ES6中的`isArray()`方法。
3. `var arr = []; Object.prototype.toString.call(arr);`

同理，通用判断对象类型的方法：

```js
function isType(type) {
    return function(obj) {
        return Object.prototype.toString.call(obj) === '[object ' + type + ']';
    }
}
var isString = isType('String');
var isArray = isType('Array');
var isObject = isType('Object');
```

## 日期

### 创建

```js
var date = new Date();
var date = new Date('December 11, 1990 19:30:00');
var date = new Date('1990-12-11T19:30:00');
var date = new Date(1990, 12, 11, 19, 30, 0);

var unixTimeStamp = Date.now();
var unixTimeStamp = Date.parse(date);
var unixTimeStamp = +date;
```

### 方法

* getFullYear(): 4位年
* getMonth(): 0-11
* getDate(): 一个月的第几天
* getDay(): 一个星期第几天 1-7
* getHours(): 0-23
* getMinutes(): 0-59
* getSeconds(): 0-59

## 正则

### 创建

```js
var patt = new RegExp(pattern, modifiers);
var patt = /pattern/modifers;

i - 修饰符用来执行不区分大小写的匹配。
g - 修饰符用来执行全文搜索（而不是在找到第一个就停止查找，是找到所有的匹配）
```

### 方法

* exec 匹配正则，返回数组，未匹配返回null
* test 匹配返回true

### 特殊字符

```
.    任意单个字符
\w    查找单词字符
\W    查找非单词字符
\d    查找数字
\D    查找非数字字符
\s    查找空白字符
\S    查找非空白字符
\b    单词边界
\B    非单词边界
\0    null字符
\n    查找换行符
\f    换页符
\r    回车符
\t    制表符
\v    垂直制表符
\xxx    八进制数
\xdd    16进制数
\uxxxx    unicode字符
n?    0次或1次
?=n    其后紧跟n的字符串
?!n    没有其后紧跟n的字符串
?:  匹配pattern，但不捕获匹配结果，用做存在性检查
```

### 实例

```
匹配中文字符的正则表达式：[\u4e00-\u9fa5\uF900-\uFA2D]

匹配特殊字符：([.*+?^${}()|[\]\/\\])

匹配空行的正则表达式：\n[\s| ]*\r

匹配HTML标记的正则表达式：/<(.*)>.*<\/\1>|<(.*) \/?>/ or /^<(\w+)\s*\/?>(?:<\/\1>|)$/

匹配首尾空格的正则表达式：(^\s*)|(\s*$)

匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*

匹配网址URL的正则表达式：http://([\w-]+\.)+[\w-]+(/[\w- ./?%&=]*)?

匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}

匹配腾讯QQ号：[1-9][\d]{4,}

匹配中国邮政编码：[1-9]\d{5}(?!\d)

匹配身份证：\d{15}|\d{18}

匹配ip地址：(\d+).(\d+).(\d+).(\d+)，对$1$2$3$4进行分别验证

用正则表达式限制只能输入数字：
onkeyup="value=value.replace(/[^\d]/g,'')"
onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^\d]/g,''))"

匹配文件后缀名
var pos = str.lastIndexOf(".");
if(pos != -1){
    return str.slice(pos+1);
}
var pattern = /[^\.]*$/;
return pattern.exec(str);
return str.match(pattern);

判断是否是CSS文件
var isCss = /.*\.css(?=\?|$)/
```

## 类和继承

### Javascript类

Javascript是一种面向原型的语言，函数是Javascript的一等公民。参考：[理解Ecmascript 6中的类和继承](http://web.jobbole.com/83372/)

#### ES5类

```js
function Animal(name) {
    this.name = name;
};
Animal.prototype = {
    call: function() {
        console.log("I'm a " + this.name);
    }
};
var lion = new Animal("lion");
lion.call();
lion.name = "Lion";
lion.call();
// 关于new
function Person(){}//定义一个函数
var person = Person();//执行函数并将返回值赋值给person，如果Person是一个类的话，新的对象不会被创建，函数内部的this将绑定到全局对象上
var person = new Person();//使用构造函数Person构造一个实例对象person，函数内部的this指向新创建的对象person
```

##### 工厂模式

![工厂模式](images/工厂模式.png)

**缺点**：工厂模式没有解决对象识别的问题，怎么知道一个对象的类型。

##### 构造函数模式

![构造函数模式](images/构造函数模式.png)

经历了4个步骤:
  
  1. 创建一个新对象
  2. 将构造函数的作用域赋给新对象（this就指向了这个对象）
  3. 执行构造函数中的代码
  4. 返回新对象

**缺点**：构造函数模式中每个方法都要在实例上重新创建一遍。
  
##### 原型模式

![原型模式](images/原型模式.png)

**缺点**: 原型上的属性是会共享的，如果是一个引用类型的属性（比如数组），它们都会使用这个数组。

##### 组合使用构造函数模式和原型模式

实例属性在构造函数中定义，共享属性在原型中定义。

#### ES6类
在ES6中，使用class关键字定义类

```js
class Animal {
    constructor(name) {
        this.name = name;
    }
    call() {
        console.log("I'm a " + this.name);
    }
    get name() {
        return this.name;
    }
    set name(name) {
        this.name = name;
    }
}
var lion = new Animal("lion");
lion.call();
lion.name = "Lion";
lion.call();
```

#### 比较
尽管两种方式下定义的结果相同，但是对于习惯写类的开发者来说，ES6语法更易编写和阅读，不需要原型，还可以使用constructor定义构造器，支持getter和setter。

### Javascript继承
Javascript采用**原型链**方式实现继承。

#### ES5继承

```js
// 方式一
Child.prototype = Object.create(Parent.prototype);
// 方式二
Child.prototype = new Parent();
// 方式三
Child.prototype.__proto__ = Parent.prototype;
```

#### ES6继承

```js
class Child extends Parent {
    constructor(name) {
        super(name);
        ...
    }
    call() {
        super.call();
    }
}
```

#### 作用域链

**作用域链查找过程**：

* 运行一个函数，生成了当前函数对象，这个函数对象会把传参、内部定义的局部变量和方法设置为自己的属性。
* 没找到就去`[[scope]]`属性里面找，然后还是找不到接着在`[[scope]]`里面找。
* 还查找不到，就爆出语法错误，记住作用域链上查找不到一个属性就爆语法错误。

**原型链查找过程**：

* 先在实例化对象里找属性。
* 找不到去`__proto__`里面找，然后还是找不到接着在`__proto__`里面找。
* `Object.prototype.__proto__`是原型链终点，值为null。 找不到输出undefined，不报语法错误。

#### 原型链

> 每个函数都有一个`prototype`属性，这个属性就是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。
 

##### `__proto__` 和 `prototype`的区别

`__proto__`指向创建这个对象的函数(constructor)的`prototype`.

```js
var f = new F(); 
//于是有
f.__proto__ === F.prototype //true
```
**总结：**

1. 对象有属性`__proto__`,指向该对象的构造函数的原型对象。
2. 方法除了有属性`__proto__`,还有属性prototype，prototype指向该方法的原型对象,这个对象的用途就是包含所有实例共享的属性和方法。 方法的属性`__proto__`指向他的构造函数的原型对象，方法的构造函数就是Function.所以方法的`__proto__`指向了`Function.prototype`. 最后`Function.prototype`指向了`object.prototype`， 毕竟在JavaScript中，万物皆对象。

![JavaScript原型链](images/JavaScript原型链.jpg)




### 事件模型
“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。

从document对象开始捕获事件，直到目标元素，然后再向上冒泡到document对象。（并非所有的事件都会经过冒泡阶段，例如focus事件和blur事件，都不会冒泡）

![event](images/event.png)

* **事件冒泡**，这是IE浏览器对事件模型的实现。即事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点(文档).
* **事件捕获**，NetSpace的实现。即不太具体的节点应该更早接收到事件，而最具体的节点应该最后接受到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。

  **缺点**：事件捕获最致命的是兼容性问题。在IE9版本以下是不能用的。 所以React的合成事件干脆就没有实现事件捕获，只支持了事件冒泡。

* **事件委托**，只需在DOM树中尽量最高的层次上添加一个事件处理程序。可以解决出现过多event handlers的情况。

### window scroll事件监听

```js
window.addEventListener("scroll", function(){
  var scrollTop = document.body.scrollTop;
  // 这里可以做一些操作，比如滚动到某个位置顶部出现导航栏
})

window.scrollTo(xPos, yPos)
```

### 如何“稀释” onscroll事件
一滚动onscroll事件会执行很多次，如何减少事件执行次数。(**使用debounce方法**)

下面实现简易版：

```js

var timer = null;
window.addEventListener('scroll', function() {
  if(typeof timer === 'number') {
    clearTimeout(timer);
  }
  
  timer = setTimeout(function() {
    //这里添加onscroll事件处理
    var scrollTop = document.body.scrollTop;
    console.log('onscroll');
  }, 1000);
  
}, false);
```

### 标准事件模型和IE事件模型的区别

1. IE事件模型没有捕获阶段
2. IE事件模型中`event`是window的全局对象，在DOM标准事件模型中是事件句柄的第一个参数
3. IE事件模型中的`target`是`event.srcElement`, 在DOM标准事件模型中是`event.target`。
4. IE事件模型中点击事件类型是`onclick
5. `,DOM标准时间模型中是`click`
5. 事件监听函数不同：IE事件模型中是`attachEvent('onclick', eventListener)`, DOM标准事件模型是`addEventListener('click', eventListener, useCapture)`

setTimeout返回一个非零的数字timeoutID来标识timer, timeoutID可以传递给clearTimeout取消延时。

其他方法： [**requestAnimationFrame**](https://segmentfault.com/q/1010000000707337)

### 事件注册跨浏览器版

```js

HTML–搭建结构

从地址栏输入URL开始到显示的过程

参考从输入 URL 到页面加载完的过程中都发生了什么事情？

1）把URL分割成几个部分：协议、主机、资源路径、查询、锚点，判断URL合法性，如果合法则进行步骤2）。其中主机host指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从该计算机获取资源的方式，常见的是HTTP、FTP，不同协议有不同的通讯内容格式；资源路径指示从服务器上获取哪一项资源。例如：

http://www.guokr.com/question/554991/
协议部分：http
主机：www.guokr.com
资源路径：/question/554991/
2）如果主机地址不是一个IP地址，通过DNS（域名解析系统）将该地址解析成IP地址。IP地址对应着网络上一台计算机，DNS服务器本身也有IP，你的网络设置包含DNS服务器的IP。例如：www.guokr.com不是一个IP，向DNS询问请求www.guokr.com对应的IP，获得IP： 111.13.57.142。这个过程里，你的电脑直接询问的DNS服务器可能没有对应的IP，就会向它的上级服务器询问，上级服务器同样可能没有，就依此一层层向上找，最高可达根节点，找到或者全部找不到为止。

3）如果主机地址中不包含端口号，根据协议的默认端口号确定一个，http协议默认端口号是80，ftp协议默认端口号是21，否则使用指定端口。端口号之于计算机就像窗口号之于银行，一家银行有多个窗口，每个窗口都有个号码，不同窗口可以负责不同的服务。端口只是一个逻辑概念，和计算机硬件没有关系。例如：www.guokr.com不包含端口号，则使用默认端口号80，如果输入的url是http://www.guokr.com:8080/，那表示不使用默认的端口号，而使用指定的端口号8080。

4）向步骤2）和3）确定的IP地址和端口号发起网络请求，通过三次握手建立TCP连接。例如：向111.13.57.142的80号端口发起连接。

5）根据http协议规范，组织一个请求的数据包，里面包含请求信息，包括请求的资源路径、你的身份等。用自然语言来表达这个数据包，大概就是：请求 /question/554991/ ，我的身份是xxxxxxx。

6）服务器响应请求，将数据返回给浏览器。数据可能是根据HTML协议组织的网页，里面包含页面的布局、文字。数据也可能是图片、脚本程序等。

7）如果步骤6）返回一个2XX信息，则根据返回数据进行页面的渲染，如果页面包含一些外链URL，例如图片、css、js代码等，按照步骤1）-6）依次获取；如果返回304，则说明浏览器缓存可用，可以直接拿来展示；否则说明存在错误，具体可参考HTTP状态码小结。根据资源的类型，将资源组织成屏幕上显示的图像，这个过程叫渲染，网页渲染是浏览器最复杂、最核心的功能。下载HTML文件解析成DOM树，CSS文件解析成CSSOM树，进一步结合JS生成Render树，由JS渲染引擎渲染。

8）将渲染好的页面图像显示出来，并开始响应用户的操作。

TCP三次握手和四次分手

参考：TCP通信的三次握手和四次撒手的详细流程（顿悟）

三次握手流程

第一次握手：建立连接时，客户端发送SYN包(SYN=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ACK=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据

四次分手流程

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。

（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。

（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。

（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。

为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？

这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建立连接请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

HTTP状态码小结

HTTP1.0和1.1的区别：keepalive，HTTP2.0添加了多路复用、head压缩、服务器推送、优先级请求

1XX 信息
2XX 成功：200 ok
3XX 重定向：301 永久重定向，302 临时重定向（ajax获取不到，见下面解释部分/HTTP1.1中302为Found，但也是一个别的地址），303 see other，304 not modified（原来缓存的文档还可以继续使用，未过期）

在HTTP权威指南中，HTTP1.0客户端发送POST请求时收到302响应不能自动重定向，而是需要向客户确认；而HTTP1.1客户端发送非GET、HEAD请求时收到302响应不能自动重定向，而是需要向客户确认，但是很多浏览器都是直接将POST重定向为GET处理。HTTP1.1中添加了303和307，303是将POST重定向为GET，而307则是POST重定向时请求客户端确认。

4XX 客户端错误：400 bad request，401 unauthorized需要用户名和密码，403 forbidden，404 not found
5XX 服务器错误：500 Internal Server Error
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
当服务器将302响应发给浏览器时，浏览器并不是直接进行ajax回调处理，而是先执行302重定向——从Response Headers中读取Location信息，然后向Location中的Url发出请求，在收到这个请求的响应后才会进行ajax回调处理。大致流程如下：
ajax -> browser -> server -> 302 -> browser(redirect) -> server -> browser -> ajax callback
而在我们的测试程序中，由于302返回的重定向URL在服务器上没有相应的处理程序，所以在ajax回调函数中得到的是404状态码；如果存在对应的URL，得到的状态码就是200。
所以，如果你想在ajax请求中根据302响应通过location.href进行重定向是不可行的。
解决方法如下：
1、修改ajax代码：
$.ajax({
    url: '/oauth/respond',
    type: 'post',
    data: data,
    dataType: 'json',
    success: function (data) {
        if (data.status == 302) {
            location.href = data.location;
        }
    }
});
2、改用form：
<form method="post" action="/oauth/respond">
</form>
HTTP readystate

0-uninitialized：请求未初始化
1-loading：下载
2-loaded：下载完成
3-interactive：渲染
4-complete：所有数据已经准备好
RESTful架构

一种互联网软件架构，结构清晰、符合标准、易于理解、扩展方便，核心是远程资源调用，Representational State Transfer表现层状态转化。http是无状态的，所以rest操作也是无状态的，不存在context约束，其目的是定义如何正确的使用web标准，优雅的使用HTTP特性。

每个URI代表一种资源
客户端和服务器之间传递这种资源的某种表现层
客户端通过4个HTTP动作：「get」获取资源、「post」新建/更新资源、「put」更新资源、「delete」删除资源来对服务器进行操作，实现表现层状态转化
WEB语义化

HTML语义化：使用包含语义的标签（header footer nav main section article等），恰当地表示文档结构，可以方便自动程序的识别
CSS语义化：为html添加有意义的id、class等补充未表达的语义
web语义化的意义

赋予标签含义，使代码结构更加清晰，尽管在标签上添加class等标签在形式上不够直接，还会给代码带来冗余
语义化的代码对于搜索引擎优化（SEO）很有帮助，结构良好的网页对于搜索引擎的亲和力是很高的，百度和谷歌也给出了很多网页结构化的建议和规范，方便他们抓取网页
有利于设备解析，如盲人阅读器对于页面的分析
便于开发者维护，有利于团队项目的可持续运作与维护
搜索引擎优化：内部优化，保证链接可跳转，提升用户体验

合理的title、description、keywords：搜索对这三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键字，不同页面title要有所不同；keywords列举出重要关键词即可
语义化的html代码，符合W3C规范：语义化代码让搜索引擎更容易理解网页
重要的html代码放在前面：搜索引擎抓HTML顺序是从上往下的，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
重要内容不要用js输出：爬虫不会执行js获取内容
少用iframe：搜索引擎不会抓取iframe中的内容

1
2
3
4
5
6
7
8
9
10
11
iframe通常用于代替长连接（comet），实现跨域通信或者历史记录的管理
1. 沙箱隔离--sandbox(HTML5)
var iframe = document.createElement("iframe");
iframe.style.display = "none";
document.body.appendChild(iframe);
frames[frames.length-1].document.write(
	"<script> parent.Array2 = Array; <\/script>"
);
2. 引用第三方内容
3. 独立的带交互内容
4. 保持独立焦点和历史记录管理的子窗口
非装饰性图片必须加alt：img的title是一个全局属性，用于给图片添加附加信息，鼠标滑动到图片上时显示；而alt是img的特有属性，是图片内容的等价描述，用于图片无法加载时展示、方便读屏器阅读图片，可以提高图片的可访问性，搜索引擎会重点分析

提高网站速度：网站速度是搜索引擎排序的一个重要指标，减少reflow和repaint
DOCTYPE

声明页面文档类型，告诉浏览器使用那种模式渲染，HTML5中<!DOCTYPE html>，无doctype声明在IE下会触发怪异模式，参考CSS盒模型

客户端存储

cookie

setCookie/getCookie，是一个key-value对，优点是兼容性好，缺点是操作繁琐、只能存储简单的数据、还会过期，而且容量有限，个数有限，会随着HTTP请求发送到服务器，存在安全隐患，站点设置httponly时，js就无法操作cookie了，禁用时可以使用http的get请求来模拟cookie

webStorage

setItem/getItem，优点是使用简单方便，缺点是IE某些版本不支持，不能存储复杂的对象，必须先转化成JSON字符串，没有索引搜索效率高，只能同步读写操作，当写入的数据比较大时可能导致js引擎堵塞

sessionStorage

用于本地存储一个会话中的数据，这些数据只有在同一个会话中的页面才能访问，并且当会话结束后数据会随之销毁，因此，不是一个持久化的本地存储，存储量很大（各浏览器要求不同）

localStorage

用于本地持久化存储，除非用户主动删除数据，否则永远不会过期，单个域名存储量大，总体数量没有限制

websql database

一个本地数据库，大大提高了web应用程序的性能，减轻了服务器的压力。存储的数据是SQL，本地存储使用的是key-value结构，性能上不如webstorage

IndexedDB

基于javascript对象继承的数据库，支持事务以及同步/异步读写操作

var indexedDB = window.indexedDB || window.webkitIndexedDB || window.msIndexedDB || window.mozIndexedDB;
var request = indexedDB.open("MyTestDB");
request.onsuccess = function(event) {
    var db = event.result;
}
cookie和session

什么是cookie

cookie分为二种：以文件方式存储在硬盘空间上的长期性的cookie以及停留在浏览器所占内存中的临时性的cookie。在浏览网站时，常会有提示，询问是否要记住登陆状态，这种情况下，登录时填写的信息会以文件的形式存放在客户端的硬盘上。在用户登陆后，session会在cookie端产生一个session_id，这个session_id是存在于浏览器所占用的内存中，关闭浏览器时会消失。而cookie采用的是客户端保持状态的方案，是一种客户端会话状态的存储机制，是服务器在本地机器上存储的小段文本或者内存中的一段数据，并随着每一个请求发送到同一个服务器。网络服务器使用HTTP头消息将cookie信息发送到客户端，在客户端，浏览器解析这些cookie并将他们保存成一个本地文件，他会自动为同一个服务器上的请求附上这些cookie。由于采用服务端保持状态的机制，客户端也需要保存一个标识，所以session机制借助于cookie来保存标识以解决HTTP协议无状态的缺陷。

什么是session

session是一种服务端信息管理机制，他把这些信息以文件的形式存放到服务器的硬盘空间上。当客户端向服务器发送请求时，要求服务器产生一个session，服务器端会首先检查下客户端的cookie中是否有session_id，是否已经过期。如果存在新鲜的session_id，服务端会根据这个值检索出session，否则重新创建一个session_id。这个值是一个加了密的字符串，同一客户端第二次session_start时，值会不一样。这个session_id是存在客户端的cookie里面的，如果客户禁止cookie，session依然可以用，只不过需要通过其他方式来获取session_id，使用HTTP的get请求直接放在url中或者post请求以表单的形式提交到服务器端，从而使服务器了解客户端的状态。

session和cookie谁更安全

答案是session，首先，如果两者一样安全，那么两者就没有必要共存了，只要cookie就好，让客户端来分担服务端的负担即可；其次，session的session_id是存放在cookie中，要攻破session，需要首先攻破cookie，攻破cookie后，还要启动session，而session启动时间不一样时，session_id也不同，不仅如此，会话结束后，session也会随着消失。

HTTP method：POST 和 GET

POST信息常用于向服务器输入数据、提交表单等，数据是放在HTTP请求消息体中，没有长度限制，且比较安全

GET信息通常用于向服务器获取数据，数据是作为URL query string参数出现，有长度限制，且只支持ASCII数据，存在信息泄露的危险

使用URL拆分出protocol、host、port、query等

定义

URL：统一资源定位符，由protocol(http:)、hostname、port(host=hostname:port)、pathname(/xxx)、search(?a=b&c=d)、hash(#XXX)组成。

解释

scheme是通信协议，常用的有http，https，ftp等
hostname是主机，服务器域名系统（DNS）主机名或者IP地址
port是端口号，省略时使用默认端口，http协议的默认端口是80，ftp协议的默认端口是21
path是资源存储路径，一般表示主机上的一个目录或者本地文件地址
query是查询字符串，以?开头，包含多个key=value对，使用&隔开
fragment是锚点，也就是我们在写html时使用的name或者id
获取

整个url: window.location.href
host: window.location.hostname
port: window.location.port
path: window.location.pathname
query: window.location.search，获取的包含?哦
fragment: window.location.hash
canvas

网易游戏笔试题-绘制时钟canvas实现

CSS–设计样式

CSS 布局

相关属性

display：none/block/inline-block/inline/table/list-item/box
display: none;和visibility: hidden;区别：前者不会渲染，后者会渲染但是不显示；前者会引起reflow和repaint，后者仅导致repaint
position：
static：默认样式，不受TRBL影响，不会被特殊定位
fixed：节点相对于浏览器窗口固定，即使页面滚动位置也不变，IE6不支持
relative：节点位置相对于父元素
absolute：绝对定位，位置计算相对于最近的已定位的祖先元素，没有已定位祖先元素时，同fixed
float: left/right
盒模型

image

strict mode盒模型

元素实际宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right
内容宽度 = width
quirks mode盒模型

元素实际宽度 = margin-left + width + margin-right
内容宽度 = width - (border-left + padding-left + padding-right + border-right)
浏览器识别方法

浏览器采用如下判断规则判断CSS解析方式

没有doctype声明的网页采用quirks mode解析
声明了doctype的网页，浏览器采用何种模式解析可参考：http://hsivonen.iki.fi/doctype/，如下有几条简单的规则可用于判断：
对于那些浏览器不能识别的doctype声明，浏览器采用strict mode解析
在doctype声明中，没有使用DTD声明或者使用HTML4以下（不包括HTML4）的DTD声明时，基本所有的浏览器都是使用quirks mode呈现，其他的则使用strict mode解析
现有有doctype声明的网页，绝大多数是采用strict mode进行解析的
在ie6中，如果在doctype声明前有一个xml声明(比如:<?xml version="1.0" encoding="iso-8859-1"?>)，则采用quirks mode解析
css3: box-sizing

CSS3中可以使用box-sizing改变盒模型

content-box：默认值，这是标准的盒模型，width和height是内容区的宽和高
padding-box：width和height包括内边距
border-box：width和height包括内边距和边框，这也是怪异模式使用的盒模型
包含块

containing block（包含块）是视觉格式化模型的一个重要概念，它与框模型类似，也可以理解为一个矩形，而这个矩形的作用是为他里面包含的元素提供一个参考，元素的尺寸和位置往往是由该元素所在的包含块决定的。元素的包含块按照如下方式定义：

浏览器（用户代理）选择根元素作为初始包含块
没有绝对定位的元素，其包含块由最近的块级祖先元素的内容边界组成
position: fixed的元素，其包含块由视口建立
position: absolute的元素，其包含块由最近的非position: static祖先按照下面步骤建立：
祖先元素为块级元素，包含块为其padding边界
祖先元素为行内元素，包含块取决于其祖先的direction属性：
direction: ltr，祖先产生的第一个盒子的上左内容边界是其包含块的上方和左方，最后一个盒子的下右内容边界是其包含块的下方和右方
direction: rtl，祖先产生的最后一个盒子的下左内容边界是其包含块的下方和左方，第一个盒子的上右右内容边界是其包含块的上方和右方
没有祖先元素，包含块为根元素的内容边界
Normal Flow

normal flow（正常流）是默认的定位方式，任何没有绝对定位（position: absolute或position: fixed）或浮动（float: left/right）的元素都将获得此属性。在这种方式下，块级元素在他们的包含块里一个一个垂直延伸，行内元素在他们的包含块里从左至右的水平排布。

BFC

BFC：块级格式化上下文，可以看做是隔离了的独立容器，是W3C CSS2.1规范中的一个概念，在CSS3中被修改为flow root

如何创建BFC：

根元素默认拥有BFC特性
浮动元素：float: left | right
绝对定位元素：position: absolute | fixed
表格的单元格、标题或行内块元素：display: table-cell | table-caption | inline-block
overflow不为visible的元素：overflow: hidden | auto | scroll

子元素不会溢出：
<div id="a">
    <div id="b">...</div>
    ...
</div>
#a{
    overflow: hidden;
}
#b{
    max-width: 100%;
}
作用：

阻止父子元素的外边距margin折叠
不会重叠浮动元素
可以包含浮动元素

通俗的来说，触发了BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时，BFC仍属于普通流

IE6-7

在IE6-7中显示引擎使用的是布局layout这个概念，当我们说一个元素拥有layout的时候，是指其hasLayout属性为true，拥有布局的元素负责本身和其子元素的尺寸设置和定位

如何触发hasLayout：

position: absolute
float: left | right
display: inline-block
width: 除auto以外的任意值
height: 除auto以外的任意值，如height: 1%
zoom: 除normal以外的任意值
IE7中 overflow: hidden | auto | scroll
行为

创建了BFC的元素会按照如下方式对其子元素进行排列：

在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠
在BFC中，每个盒子的左外边缘margin-left会触碰到容器的左边缘border-left，即使存在浮动也是如此，除非这个子元素本身也创建了一个新的BFC
margin折叠

外边距重叠是指，常规流中同一个BFC的两个块级元素上下毗邻且都定义了不为0的外边距值，没有padding和border将他们分开时，那么这两个元素之间的距离将小于二者外边距的和。

两个或多个毗邻的普通流中的块元素垂直方向上的margin折叠
浮动元素/inline-block/绝对定位元素的margin不会和垂直方向上的其他元素折叠
创建了BFC的元素不会和他的子元素发生margin折叠
元素自身的margin-top和margin-bottom相临时也会折叠
计算

都是正值，取绝对值最大的
都是负值，取绝对值最大的
有正有负，取绝对值最大的正和绝对值最大的负相加
元素绝对居中

触发了BFC元素：
float元素：1)元素设置宽度 2)position: relative 3)left/right设置为50% 4)margin设置为宽度一半乘以-1
absolute元素
1)元素设置宽度 2)left/right设置为50% 3)margin设置为宽度一半乘以-1
1)元素设置宽度 2)top: 0; right: 0; bottom: 0; left: 0; 3)margin: auto;
普通流
行内元素
水平居中：父元素设置text-align: center
单行时垂直居中：行内可替换元素父元素设置vertical-align: center;，否则父元素设置line-height为其高度
块级元素
1)元素设置宽度 2)margin:0 auto 3)IE6下父元素设置text-align: center，再给子元素恢复需要的值
不设置宽度时：transform: translateX(-50%);
固定尺寸的img 在固定尺寸的div中怎么水平居中，竖直居中；引申：不定尺寸的img 在固定尺寸的div中怎么水平居中，竖直居中, 写出img 和 div的css规则

div{
    width: 800px;
    height: 600px;
    border: 1px solid red;
    position: relative;
}    
img{
    /*
    width: 400px;
    height: 400px;
    margin-left: 200px;
    margin-top: 100px;
    */
    position: absolute;
    margin: auto;
    top: 0;            
    right: 0;
    bottom: 0;
    left: 0;
}
解决float元素引起的父元素高度塌陷

/**
* 在标准浏览器下使用
* 1 content内容为空格用于修改opera浏览器下文档中出现contentEditable属性时在清理浮动元素上下的空白
* 2 使用display:table可以防止容器和子元素top-margin折叠，这样能使清理效果与BFC，IE6/7下的zoom：1一致
**/    
.clearfix:before,
.clearfix:after {
    content: " "; /* 1 */
    display: table; /* 2*/
}
.clearfix:after {
    clear: both;
}
/**
* IE6/7下使用
* 通过触发hasLayout实现包含浮动
**/
.clearfix {
    *zoom: 1;
}
flexbox

使用css实现两栏布局，左侧宽度固定，右侧自适应

关于使用正padding和负margin对冲实现多列等高布局时，所有列都设置相同的正的上/下padding和负的上/下margin，并在所有列外面添加一个容器，并设置overflow: hidden把溢出背景切掉。这种方法并不是自适应高度的实现，只是利用了overflow: hidden来隐藏每个列的多余部分。给所有列先设置了一个10000px的空白占位高度，把整个div往上挤了10000px，然后又通过负margin将所有列往下挪了10000px。细节请戳→→从负margin到css盒模型

HTML

<div class="container">
    <div class="left"></div>
    <div class="main"></div>
</div>
方法1

.container {
    overflow: hidden;
}
.left {
    float: left;
    width: 200px;
    //margin-right: 10px;
    padding-bottom: 10000px;
    margin-bottom: -10000px;
}
.main {
    margin-left: 210px;
    //overflow: hidden;
    padding-bottom: 10000px;
    margin-bottom: -10000px;
}
方法2

.container {
    overflow: hidden;
}
.left {
    float: left;
    width: 200px;
    margin-right: 10px;
    padding-bottom: 10000px;
    margin-bottom: -10000px;
}
.main {
    //margin-left: 210px;
    overflow: hidden;
    padding-bottom: 10000px;
    margin-bottom: -10000px;
}
方法3

.container {
    display: -webkit-box;
    display: box;
}
.left {
    width: 200px;
    margin-right: 10px;
}
.main {
    -webkit-box-flex: 1;
    box-flex: 1;
}
引申-三栏布局

float+margin

<style>
    .left {
        float: left;
        width: 100px;
    }
    .right {
        float: right;
        width: 100px;
    }
    .main {
        margin: 0 100px;
    }
</style>
<div class="container">
    <div class="left"></div>
    <div class="right"></div>
    <div class="main"></div>
</div>
圣杯布局

<style>
    .container {
        padding: 0 100px;
    }
    .left {
        float: left;
        width: 100px;
        margin-left: -100%;
        position: relative;
        left: -100px;
    }
    .right {
        float: left;
        width: 100px;
        margin-left: -100px;
        position: relative;
        right: -100px;
    }
    .main {
        float: left;
        width: 100%;
    }
</style>
<div class="container">
    <div class="main"></div>
    <div class="left"></div>
    <div class="right"></div>
</div>
双飞翼布局

<style>
    .left {
        float: left;
        width: 100px;
        margin-left: -100%;
    }
    .right {
        float: left;
        width: 100px;
        margin-left: -100%;
        position: relative;
        left: 100px;
    }
    .main {
        float: left;
        width: 100%;
    }
    .main-content {
        margin-left: 200px;
    }
</style>
<div class="container">
    <div class="main">
        <div class="main-content">
        </div>
    </div>
    <div class="left"></div>
    <div class="right"></div>        
</div>
web中的图标

随着时代的变迁和技术的不断革新，在当今这个时代，web中的图标不再仅仅是局限于图片，还有雪碧图、字体图标、SVG图标等。对于设计师而言，他们关心的是像素的完美和体验的一致性，而前端开发工程师则更为关心页面的可访问性、性能、重构灵活性、可复用性、可维护性等。如何根据不同的DPI展示不同规格的图标素材也是个难题。

图片

优点

更换简单
图标大小易掌握
缺点

增加HTTP请求数
不易适配各种终端和分辨率，可能会造成图标模糊
不易修改图标样式，比如颜色、阴影等
不易维护
雪碧图 Sprites

优点

将图标合成，减少HTTP请求数
可以是任意图形、任意色彩
兼容性好
可以使用background-size属性调整图标大小
缺点

增加开发时间，合成需要人工成本
增加维护成本
字体图标 iconfont

优点

减少HTTP请求
可以使用font属性修改大小、颜色等
体积小
缺点

显示位置和大小受限于制作的icon
不兼容旧的手机浏览器
SVG

优点

矢量图形文件，可以随意修改大小，不影响图片质量
可以使用CSS样式来定义图标颜色、尺寸等
所有的SVG图标在一个SVG文件中，节省HTTP请求
支持gzip压缩
缺点

兼容性差
需要额外的学习成本
Data URL

优点：不增加请求数
缺点

通常比图片大
每次加载需要解码
难以维护
选择

如果需要的是信息丰富的图片，而不仅仅是图标，那么使用 图片
如果不是展示类图形，而是装饰性的图形，一般不随意改动，可以考虑使用 png 雪碧图
如果图标需要适配于高分辨率环境下，可以考虑使用 SVG 雪碧图
仅仅是需要Icon这些小图标，并且可以做一些个性化样式，可以考虑使用 Icon Font
仅仅需要图标更具扩展性，又不希望加载额外的图标，可以考虑在页面中直接使用 SVG代码绘制的矢量图
使用文字替换图片技术→有利于SEO

<h2><span>Hello world</span></h2>
h2{
    background: url(image.gif) no-repeat;
    width: 150px;
    height: 35px;
}
span{
    display: none;
}            

<h1 class="nir">content</h1>
.nir{
    height: 100px;
    width: 400px;
    overflow: hidden;
}
.nir:before{
    content: url(image.gif);
    display: inline-block;
    font-size: 0;
    line-height: 0;
}

<h2><span></span>Hello world</h2>
h2 {
    width: 150px;
    height: 35px;
    position: relative;
}
h2 span{
    background: url(image.gif) no-repeat;
    position: absolute;
    width: 100%;
    height: 100%;
}
CSS 选择器

匹配顺序

从右往左

匹配规则

根据主选择器进行划分，包括ID规则，class规则，标签规则，*规则

写法

css 组合选择器

后代选择器 div p
子元素选择器 div>p
相邻兄弟选择器 div+p 相邻的兄弟
普通兄弟选择器 div~p 返回一组值
css 伪类

:link :visited :hover :active(顺序很重要)
:first-child :nth-child(expression)
:focus :blur
:not :have
css 伪元素

:first-letter :first-line
:before :after
::selection 匹配突出显示的文本 只接受2个属性：background和color

注意伪元素和伪类的区别：first-letter vs first-child
nth-of-type vs nth-child
ele:nth-of-type(n)是指父元素下第n个ele子元素
ele:nth-child(n)是指父元素下的第n个子元素，若类型为ele则命中，否则选择失败
css 属性选择器

[attribute]
[attribute = value]
[attribute ~= value]包含
[attribute *= value]包含
[attribute |= value]以value开头且必须是一个单词
[attribute ^= value]以value开头
[attribute $= value]以value结尾
[:checked] [:selected]
CSS hack技术

属性前缀法(即类内部Hack)：例如 IE6能识别下划线_和星号*，IE7能识别星号*，但不能识别下划线_，IE6~IE10都认识\9，但firefox上述三个都不认识

选择器前缀法(即选择器Hack)：例如 IE6能识别*html .class{}，IE7能识别*+html .class{}或者*:first-child+html .class{}

IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： <!--[if IE]>IE浏览器显示的内容 <![endif]-->，针对IE6及以下版本：<!--[if lt IE 6]>只在IE6-显示的内容 <![endif]-->。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。

CSS 颜色

rgba颜色中a是透明度，取值为0.0-1.0，0代表完全透明，1代表不透明，兼容Firefox和IE的写法是：

1
2
3
filter: alpha(Opacity=50);
-moz-opacity: 0.5;
opacity: 0.5;
无样式内容闪烁 FOUC

定义

IE6使用@import引入CSS样式时，会导致某些页面以无样式显示页面内容的瞬间闪烁，这种现象被称为文档样式短暂失效

如何避免

避免使用@import方式引入css
使用link标签将样式文件放到head部分
link和@import

link是HTML标签，@import是CSS方式
link最大限度支持并行下载，而@import过度嵌套会导致FOUC出现
link可以通过rel属性指定候选样式
浏览器对于link支持早于@import方式
CSS预处理器和CSS后处理器

css作为一门标记型语言，语法相对简单，欠缺逻辑性，不方便维护和扩展，不利于复用。为了写出组织良好且易于维护的css代码，引入了CSS预处理器概念，变量、mixin、运算及函数的引用、嵌套等功能大大简化了CSS的编写，提高代码开发效率。

CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的 CSS 预处理器。我们很久以前就在用CSS后处理器了，最典型的例子是CSS压缩工具（如 clean-css等），还有最近比较火的 Autoprefixer，以 Can I Use 上的 浏览器支持数据为基础，自动处理兼容性问题。

具体请戳 前端工具

@base: #f938ab;
.box-shadow(@style, @c) when (iscolor(@c)) {
-webkit-box-shadow: @style @c;
box-shadow: @style @c;
}
.box-shadow(@style, @alpha: 50%) when (isnumber(@alpha)) {
.box-shadow(@style, rgba(0, 0, 0, @alpha));
}
.box {
color: saturate(@base, 5%);
border-color: lighten(@base, 30%);
div {.box-shadow(0 0 5px, 30%)}
}
CSS hyphens实现英文单词完美展示

word-wrap: 允许长单词或url地址转换到下一行，取值有 normal/break-word;

word-break: 自动换行处理方法，取值有 normal/break-all/keep-all，(只在半角空格或者连字符处换行)

代码

<html lang="en-US">//支持hyphens
    <head>
        <style>
            div{
                -moz-hyphens: auto;
                -ms-hyphens: auto;
                -webkit-hyphens: auto;
                hyphens: auto;
                word-wrap: break-word;
                //word-break: break-all;
            }
        </style>
    </head>
</html>
CSS3 动画

transform: translate/rotate/scale/skew/matrix
transition: property duration timing-function(linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(a,b,c,d))
animation: name duration timing-function delay iteration-count direction play-state

.cylon_eye {
  -webkit-animation: move_eye 4s linear 0s infinite alternate;
     -moz-animation: move_eye 4s linear 0s infinite alternate;
       -o-animation: move_eye 4s linear 0s infinite alternate;
          animation: move_eye 4s linear 0s infinite alternate;
}
@-webkit-keyframes move_eye {
    from { margin-left:-20%; } 
    to { margin-left:100%; }
}
@-moz-keyframes move_eye { 
    from { margin-left:-20%; } 
    to { margin-left:100%; }  
}
@-o-keyframes move_eye { 
    from { margin-left:-20%; } 
    to { margin-left:100%; }  
}
@keyframes move_eye { 
    from { margin-left:-20%; } 
    to { margin-left:100%; }  
}
使用1、2、3、5个标签画红十字

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>使用1、2、3、5个标签画红十字</title>
    <style>
        /**包裹div样式*/
        .container{        
            width: 150px;        
            height:150px;        
            float:left;        
            margin:10px 0px 0px 10px;    
        }    
        /**用1个div标签实现*/    
        .cross{        
            width:50px;        
            height:150px;        
            background:red;        
            vertical-align: middle;        
            position:relative;        
            left:50px;    
        }    
        .cross:before{        
            position: absolute;        
            top:50px;        
            left:-50px;                
            width:50px;        
            height:50px;        
            background:red;        
            vertical-align: middle;        
            content:"";    
        }    
        .cross:after{        
            position: absolute;        
            top:50px;        
            left:50px;                
            width:50px;        
            height:50px;        
            background:red;        
            vertical-align: middle;        
            content:"";    
        }    
        /**用2个div标签实现*/    
        .s_first{        
            position:relative;        
            top:50px;        
            left:0px;        
            width:150px;        
            height:50px;        
            background:red;    
        }    
        .s_second{        
            position:relative;        
            top:-50px;        
            left:50px;        
            width:50px;        
            height:150px;        
            background:red;    
        }    
        /**用3个div标签实现*/    
        .t_first{        
            position:relative;        
            top:0px;        
            left:50px;        
            width:50px;        
            height:150px;        
            background:red;    
        }    
        .t_second{        
            position:relative;        
            top:-100px;        
            left:0px;        
            width:50px;        
            height:50px;        
            background:red;    
        }    
        .t_third{        
            position:relative;        
            top:-150px;        
            left:100px;        
            width:50px;        
            height:50px;        
            background:red;    
        }    
        /**用5个div标签实现*/    
        .f_first{        
            position:relative;        
            top:0px;        
            left:50px;        
            width:50px;        
            height:50px;        
            background:red;    
        }    
        .f_second{        
            position:relative;        
            top:0px;        
            left:0px;        
            width:50px;        
            height:50px;        
            background:red;    
        }    
        .f_third{        
            position:relative;        
            top:-50px;        
            left:50px;        
            width:50px;        
            height:50px;        
            background:red;    
        }    
        .f_fourth{        
            position:relative;        
            top:-100px;        
            left:100px;        
            width:50px;        
            height:50px;        
            background:red;    
        }    
        .f_fifth{        
            position:relative;        
            top:-100px;        
            left:50px;        
            width:50px;        
            height:50px;        
            background:red;    
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="cross"></div>
    </div>

    <div class="container">    
        <div class="s_first"></div>    
        <div class="s_second"></div>
    </div>

    <div class="container">    
        <div class="t_first"></div>    
        <div class="t_second"></div>    
        <div class="t_third"></div>
    </div>

    <div class="container">    
        <div class="f_first"></div>    
        <div class="f_second"></div>    
        <div class="f_third"></div>    
        <div class="f_fourth"></div>    
        <div class="f_fifth"></div>
    </div>
</body>
</html>
CSS 绘制箭头

.arrow-up {
    width: 0;
    height: 0;
    font-size: 0;
    line-height: 0;
    border: 5px solid transparent;
    border-bottom: 5px solid red;
}
CSS+JS制作轮播

bootstrap实现轮播

CSS 实现浮层

<div class="modal" id="zero">
   <div class="inner_modal">
     <div class="close">x</div>
     <img src="images/div_by_zero.jpg">
     <h1>Oh crap! Did you divide by zero?</h1>
   </div>
 </div>
 .modal {
    position: absolute;
    top: 70px;
    left: 0;
    right: 0;
}        
.inner_modal {
    position: relative;
    width: 700px;
    margin: auto;
    padding: 30px;
    background-color: #17171a;
}        
#zero {
    display: none;
}        
.close {
    position: absolute;
    top: 5px;
    right: 10px;
    padding: 5px;
    font-size: 22px;
    color: #ffa200;
    cursor: pointer;
}
CSS 文本溢出显示

单行文本

overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
多行文本

overflow: hidden;
text-overflow: ellipsis;
display: -webkit-box;
display: box;
-webkit-box-orient: vertical;
box-orient: vertical;
-webkit-line-clamp: 2;
如何让height:100%起作用

参考：浏览器中width、height计算

CSS reset

CSS reset文件可以重置浏览器对于HTML元素的默认样式，让各个浏览器的CSS样式有一个统一的基准。这是由于PC时代各种浏览器采用不同的标准，造成对于html标签的默认样式不同，样式难以统一。但是在跨入无线web时代后，尽管碎片化问题依然存在，但是无线web上各个厂商对很多规范都进行了支持，不一定需要reset，只需要做一个统一化处理，这就是著名的reset与normalize之争。

Javascript–定义行为

数据

javascript数据类型

null：表示对象没有声明，该处不应有值，典型的应用是作为函数的参数或者对象原型链的终点

undefined：表示缺少值，包括以下几种情况：

变量已经声明，但是没有赋值

调用函数时，应该提供的参数没有被提供

对象没有赋值的属性

函数没有返回值，默认返回undefined

boolean：布尔型，true/false

number：数值

string

array

object

定义

var obj = {}

var obj = new Object()

var obj = Object.create(Object.prototype)

new关键字

使用new关键字调用构造函数时，会首先创建一个空对象，并且this引用该对象，同时还继承了函数的原型，属性和方法被加入到this引用的对象中，新创建的对象由this所引用，最后隐式返回this。

判断数据类型

typeof

typeof 是一个一元运算符，放在一个运算数之前，运算数可以是任意类型，返回值是一个字符串，说明运算数的类型，包括undefined boolean number string function object，对于array类型会返回object，null类型会返回undefined。我们可以使用typeof来判断对象是否存在，即typeof a !== 'undefined'

instanceof

instanceof 是用来判断对象是否是另一个对象的实例，实际上是instance.__proto__ === object（function参数arguments是一个伪数组，需要使用Array.prototype.slice.call(arguments)转换成标准数组才能使用数组的一些函数）

判断一个对象是否为数组

function isArray(arg) {
    if(typeof arg === "object") {
        return Object.prototype.toString.call(arg) === "[object Array]";
    }
    return false;
}
判断一个对象是否为函数

function isFunction(arg) {
    if(arg) {
        if(typeof('/./') !== 'function') {
            return typeof arg === 'function';
        } else {
            return Object.prototype.toString.call(arg) === '[object Function]';
        }
    }
}
通用代码

function isType(type) {
    return function(obj) {
        return Object.prototype.toString.call(obj) === '[object ' + type + ']';
    }
}
var isString = isType('String');
var isArray = isType('Array');
var isObject = isType('Object');
字符串

length
charAt()
concat()
indexOf()
match()：正则匹配，返回数组
repeat()
replace()：正则替换
search()：正则查找，同indexOf
slice()
split()：字符串->数组
startsWith()
substr(pos, length)
substring(start, end)
toLowerCase()
trim()
数组

length
concat()：合并数组，可以有多个参数
join()：数组->字符串，字符串->数组：split()
pop()：删除最后一个元素
shift()：删除第一个元素
push()：末尾插入元素
unshift()：头部插入元素
reverse()：数组逆序
slice(start, end)：返回一个[start, end)的新数组，原数组不变
splice()

var arr1 = [1, 2, 3, 4];
var arr2 = arr1.splice(0, 3);
console.log(arr1, arr2);    // [4] [1, 2, 3]
var arr3 = [1, 2, 3, 4];
arr3.splice(0, 0, 0);
console.log(arr3);            // [0, 1, 2, 3, 4]
var arr4 = [1, 2, 3, 4];
arr4.splice(0, 1, 5);
console.log(arr4);            // [5, 2, 3, 4]
var arr5 = [1, 2, 3, 4];
arr5.splice(1, 3);
console.log(arr5);            // [1]
sort()：排序

function fillArray(arr, start, end, num) {
    start = start || 1;
    end = end || 100;
    num = num || 10;
    var width = end - start;
    for(var i = num; i > 0; --i) {
        arr.push((~~(Math.random()*width)+start));
    }
    return arr;
}
function normalize(arr) {
    if(arr && Array.isArray(arr)) {
        var map = {};
        for(var i = arr.length; i >= 0; --i) {
            if(arr[i] in map) {
                arr.splice(i, 1);
            } else {
                map[arr[i]] = true;
            }
        }
    }
    return arr;
}
var input = [];
fillArray(input, 1, 100, 10);
input.sort(function(a, b) {
    return a-b;
});
normalize(input);
日期

创建

var date = new Date();
var date = new Date('December 11, 1990 19:30:00');
var date = new Date('1990-12-11T19:30:00');
var date = new Date(1990, 12, 11, 19, 30, 0);

var unixTimeStamp = Date.now();
var unixTimeStamp = Date.parse(date);
var unixTimeStamp = +date;
方法

getFullYear(): 4位年
getMonth(): 0-11
getDate(): 一个月的第几天
getDay(): 一个星期第几天 1-7
getHours(): 0-23
getMinutes(): 0-59
getSeconds(): 0-59
正则

创建

var patt = new RegExp(pattern, modifiers);
var patt = /pattern/modifiers;        
i - 修饰符是用来执行不区分大小写的匹配。
g - 修饰符是用于执行全文的搜索（而不是在找到第一个就停止查找,而是找到所有的匹配）。
方法

exec 匹配正则，返回数组，未匹配返回null
test 匹配返回true
特殊字符

.    任意单个字符
\w    查找单词字符
\W    查找非单词字符
\d    查找数字
\D    查找非数字字符
\s    查找空白字符
\S    查找非空白字符
\b    单词边界
\B    非单词边界
\0    null字符
\n    查找换行符
\f    换页符
\r    回车符
\t    制表符
\v    垂直制表符
\xxx    八进制数
\xdd    16进制数
\uxxxx    unicode字符
n?    0次或1次
?=n    其后紧跟n的字符串
?!n    没有其后紧跟n的字符串
?:  匹配pattern，但不捕获匹配结果，用做存在性检查
实例

匹配中文字符的正则表达式：[\u4e00-\u9fa5\uF900-\uFA2D]

匹配特殊字符：([.*+?^${}()|[\]\/\\])

匹配空行的正则表达式：\n[\s| ]*\r

匹配HTML标记的正则表达式：/<(.*)>.*<\/\1>|<(.*) \/?>/ or /^<(\w+)\s*\/?>(?:<\/\1>|)$/

匹配首尾空格的正则表达式：(^\s*)|(\s*$)

匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*

匹配网址URL的正则表达式：http://([\w-]+\.)+[\w-]+(/[\w- ./?%&=]*)?

匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}

匹配腾讯QQ号：[1-9][\d]{4,}

匹配中国邮政编码：[1-9]\d{5}(?!\d)

匹配身份证：\d{15}|\d{18}

匹配ip地址：(\d+).(\d+).(\d+).(\d+)，对$1$2$3$4进行分别验证

用正则表达式限制只能输入数字：
onkeyup="value=value.replace(/[^\d]/g,'')"
onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^\d]/g,''))"

匹配文件后缀名
var pos = str.lastIndexOf(".");
if(pos != -1){
    return str.slice(pos+1);
}
var pattern = /[^\.]*$/;
return pattern.exec(str);
return str.match(pattern);

判断是否是CSS文件
var isCss = /.*\.css(?=\?|$)/
非捕获型分组

创建反向引用的分组，一般称为捕获型分组。反之，不会创建反向引用的分组就是非捕获型分组，分组多了会影响效率。

var str = "#123456";
var cap = /#(\w+)/g;
var nocap = /#(?:\w)/g
console.log(cap.test(str));     // true
console.log(RegExp.$1);            // 123456
console.log(nocap.test(str));    // true
console.log(RegExp.$1);            // 空
函数

在javascript中，函数是第一等公民，函数可以返回函数，词法上支持闭包。如何有效利用闭包和作用域是成为一个伟大的javascript开发者的关键。

函数柯里化

柯里化是这样的一个转换过程，把接受多个参数的函数变换成接受一个单一参数的函数，如果其他的函数是必要时，返回接受余下的参数且返回结果的新函数。函数柯里化允许和鼓励分隔复杂功能变成更小更容易分析的部分。这些小的逻辑单元显然是更容易理解和测试的，然后你的应用就会变成干净而整洁的组合，由一些小单元组成的组合。

柯里化是将多个参数合成一个object参数，这个object字段不是固定的，对于同一个函数来说，无论后期参数的顺序、数量、类型如何变化，接口部分是不变的，所以适合作为构造方法来用
柯里化可以解决动态参数的问题，在不需要改变接口的情况下可以新增不同特性，且对调用端透明，解决了js里面没有重载带来的一些麻烦
柯里化有3个典型应用：参数复用，提前返回、延迟计算
柯里化：把参数数组首个砍掉；反柯里化：把某个参数塞到参数数组的第一个。柯里化跟反柯里化都可以返回新函数，相比原函数，他们接受的参数一个是被砍头过的，一个是接头过的
类和继承

Javascript类

Javascript是一种面向原型的语言，函数是javascript的一等公民。参考：理解Ecmascript 6中的类和继承

ES5 类

在ES5中，可以使用函数模拟类的实现。在javascript中，灵活的函数允许我们模拟类的封装。通过这个技巧，可以扩展对象的原型。

function Animal(name) {
    this.name = name;
};
Animal.prototype = {
    call: function() {
        console.log("I'm a " + this.name);
    }
};
var lion = new Animal("lion");
lion.call();
lion.name = "Lion";
lion.call();
// 关于new
function Person(){}//定义一个函数
var person = Person();//执行函数并将返回值赋值给person，如果Person是一个类的话，新的对象不会被创建，函数内部的this将绑定到全局对象上
var person = new Person();//使用构造函数Person构造一个实例对象person，函数内部的this指向新创建的对象person
ES6 类

在ES6中，使用class关键字定义类

class Animal {
    constructor(name) {
        this.name = name;
    }
    call() {
        console.log("I'm a " + this.name);
    }
    get name() {
        return this.name;
    }
    set name(name) {
        this.name = name;
    }
}
var lion = new Animal("lion");
lion.call();
lion.name = "Lion";
lion.call();
比较

尽管两种方式下定义的结果相同，但是对于习惯写类的开发者来说，ES6语法更易编写和阅读，不需要原型，还可以使用constructor定义构造器，支持getter和setter。

Javascript继承

Javascript采用原型链方式实现继承，每个构造函数都有一个prototype属性，指向父对象。这个对象的所有属性和方法，都会被构造函数的实例继承。也就是说，我们可以将那些通用的属性和方法，直接定义在prototype属性上。hasOwnProperty可以用来判断一个对象是否拥有某属性或包含某成员，in可以用来判断一个对象或者他的原型链中是否拥有某属性或包含某成员。原型链的意思是，在进行属性查找时，javascript会向上遍历整个原型链，直到到达原型链的顶部，也就是Object.prototype为止。

ES5 继承

// 方式一
Child.prototype = Object.create(Parent.prototype);
// 方式二
Child.prototype = new Parent();
// 方式三
Child.prototype.__proto__ = Parent.prototype;
ES6 继承

使用extends代替原型绑定方式实现继承，通过super关键字保持对基类的引用。

class Child extends Parent {
    constructor(name) {
        super(name);
        ...
    }
    call() {
        super.call();
    }
}
相关题目

属性查找

function foo() {
    this.add = function (x, y) {
        return x + y;
    }
}

foo.prototype.add = function (x, y) {
    return x + y + 10;
}

Object.prototype.subtract = function (x, y) {
    return x - y;
}

var f = new foo();
alert(f.add(1, 2)); //结果是3，而不是13
alert(f.subtract(1, 2)); //结果是-1
实例化对象

var obj1 = new Ob();
var obj2 = new Ob();
obj1.a = 1;
console.log (obj1.a);
console.log (obj2.a);
Ob.prototype.a = 2;
console.log (obj1.a);
console.log (obj2.a);    
//答    1, undefined, 1, 2
//解释   实例变量    原型中的变量什么的，原型链搜索
ES6新增功能

github es6features

ES6新特性概览

ECMAScript 6入门

事件模型

DOM事件

事件是javascript应用跳动的心脏，事件的传播顺序有两种：事件捕捉和事件冒泡。

冒泡型事件

这是IE浏览器对事件模型的实现。顾名思义，事件由叶子节点沿祖先节点一直向上传递直到根节点。冒泡型事件的基本思想：事件按照从特定的事件目标开始到最不确定的事件目标。

捕获型事件

NetSpace的实现，与冒泡型相反，由DOM树最顶层元素一直到最精确的元素。

DOM标准事件模型

同时支持上面两种事件模型，从document对象开始捕获事件，直到目标元素，然后再向上冒泡到document对象。（并非所有的事件都会经过冒泡阶段，例如focus事件和blur事件，都不会冒泡）

image

window scroll事件监听

window.addEventListener("scroll", function() {
    var scrollTop = document.body.scrollTop;
});
window.scrollTo(xPos, yPos);
标准事件模型和IE事件模型的区别

IE事件模型没有捕获阶段
IE事件模型中event是window的全局对象，而在DOM标准事件模型中是事件句柄的第一个参数
IE事件模型中target是event.srcElement，在DOM标准事件模型中是event.target
IE事件模型中点击事件类型为onclick，DOM标准事件模型中是click
事件监听函数不同：attachEvent("onClick", eventListener)和addEventListener("click", eventListener, useCapture)，其中第三个参数决定了监听函数执行时间是捕获阶段还是冒泡阶段
事件注册跨浏览器版

var EventUtil = {
    getEvent: function(event) {
        return event || window.event;
    },
    getTarget: function(event) {
        return event.target || event.srcElement;
    },
    preventDefault: function(event) {
        if(event.preventDefault) {
            event.preventDefault();
        } else {
            // javascript中return false可以阻止默认行为，query中是阻止默认行为+冒泡
            event.returnValue = false;
        }
    },
    stopPropagation: function(event) {
        if(event.stopPropagation) {
            event.stopPropagation();
        } else {
            event.cancelBubble = true;
        }
    },
    on: function(ele, type, handler) {
        if(ele.addEventListener) {
            ele.addEventListener(type, handler, false);
        } else if(ele.attachEvent) {
            ele.attachEvent("on"+type, handler);
        } else {
            ele["on"+type] = handler;
        }
    },
    off: function(ele, type, handler) {
        if(ele.removeEventListener) {
            ele.removeEventListener(type, handler, false);
        } else if(ele.detachEvent) {
            ele.detachEvent("on"+type, handler);
        } else {
            ele["on"+type] = null;
        }
    }
};

var DOMUtil = {
    text: function(ele) {
        if("textContent" in ele) {
            return ele.textContent;
        }
        return ele.innerText;
    },
    prop: function(ele, propName) {
        return ele.getAttribute(propName);
    }
}
```

## call和apply的区别

`call`和`apply`都可以改变运行时函数的上下文。`call()`方法接受的是若干个参数的列表，而`apply()`方法接受的是一个包含多个参数的数组。

注意：ES6 中的 spread运算符可以代替`apply`方法。

```js
// ES5的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f(...args);
```

## JS的垃圾回收机制
 标记清除。
 
 可以用一位来标记变量，当变量进入环境可以标记“进入环境”，当变量离开环境就可以标记为“离开环境”。
 
 引用计数。
 
 记录变量被引用次数，如果次数为0，就可以回收。会存在相互引用的问题。
 
## JS闭包 

闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境。
 
## 手写ajax

```js
var xmlhttp=null;//声明一个变量，用来实例化XMLHttpRequest对象
if (window.XMLHttpRequest)
  {
  xmlhttp=new XMLHttpRequest();// 新版本的浏览器可以直接创建XMLHttpRequest对象
  }
  
else if (window.ActiveXObject)
  {
  xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");// IE5或IE6没有XMLHttpRequest对象，而是用的ActiveXObject对象
  }
  
  
if (xmlhttp!=null)
  {
  xmlhttp.onreadystatechange=state_Change;//指定响应函数为state_Change
  xmlhttp.open("GET","/example/xdom/note.xml",true);//指定请求，这里要访问在/example/xdom路径下的note.xml文件，true代表的使用的是异步请求
  xmlhttp.send(null);//发送请求
  } 
else
  {
  alert("Your browser does not support XMLHTTP.");
  }

//创建具体的响应函数state_Change
function state_Change()
{
if (xmlhttp.readyState==4)
  {
  if (xmlhttp.status==200)
    {
    // 这里应该是函数具体的逻辑
    }
  else
    {
    alert("Problem retrieving XML data");
    }
  }
}
```

## 匿名函数的优势

1. 可以避免变量污染，占用全局变量名。
2. 参数保护。函数是独立作用域，可以使用闭包保存临时变量。
3. 模块化编程。降低风险，只暴露出想要暴露的接口。



## clone一个对象

* JSON.parse(JSON.stringify(o))//还行，深度复制的速度是最快的(和extends其实差不多)，浅度复制的话还是assign吧，但是函数对象，date对象等等json不支持的都没戏咧
 
* Object.create(o)//虽然是加了层原型链，但是我感觉还是不错的，不过前者的对象变化会影响到后面，基本不算是复制了
* Object.assign(就是一个浅复制呗，writable特性无法复制)
* $.extends(第一个参数为true的话是支持深度复制的)
* replaceState(奇葩啊，这也行..)

## CSRF(跨站点请求伪造)

* 传一个token

## macro-task与micro-task

在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。

### 具体分类

**macro-task**: script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering 

**micro-task**: process.nextTick, Promises（这里指浏览器实现的原生 Promise）, Object.observe, MutationObserver



# 浏览器缓存机制 （重新整理）

主要就是HTTP协议定义的缓存机制（如： Expires； Cache-control等）

`cache-control: max-age = 300.`

## Last-modified缺点
Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。



如果 Last-Modified 和 ETag 同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。

#HTTP协议

## 头部含义

* Accept: 浏览器能够处理的内容类型
* Accept-Charset: 浏览器能够显示的字符集
* Accept-Encoding: 浏览器能够处理的编码
* Accept-Language: 浏览器当前设置的语言
* Connection: 浏览器与服务器之间的连接类型
* Cookie： 当前页面设置的任何Cokkie
* Host: 描述请求将被发送的目的地，包括，且仅仅包括域名和端口号。在任何类型请求中，request都会包含此header信息。
* origin: 用来说明请求从哪里发起的，包括，且仅仅包括协议和域名。这个参数一般只存在于CORS跨域请求中，可以看到response有对应的header：Access-Control-Allow-Origin。
* Referer: 发出请求的页面的URI。
* User-Agent: 浏览器的用户代理字符串

## get, put, post, delete
* **get**: GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样.
* **put**: PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样
* **post**: 向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样
* **delete**: 用来删除某一个资源的，该请求就像数据库的delete操作。

**put 和 post的区别**： POST主要作用在一个集合资源之上的（url），而PUT主要作用在一个具体资源之上的（url/xxx），通俗一下讲就是，如URL可以在客户端确定，那么可使用PUT，否则用POST。就是post的请求是会产生副作用的。

## 状态码

* 1XX：信息性状态码，接收的请求正在处理
* 2XX：成功状态码：请求正常处理
* 3XX：重定向状态码，需要进行附加工作来完成请求
* 4XX：客户端错误状态码，服务器无法处理请求
* 5XX：服务器错误状态码，服务器处理请求出错


**200 OK**

就是被正常处理

**204 No Content**

就是请求正常处理，没有内容返回

**206 Partial Content**

表示客户端进行了范围请求，服务器成功执行了这个部分的GET请求

**301 Moved Permanently**

永久性重定向，资源被分配到了新的URL。注意，这个返回的code是服务器对浏览器说的，是想让浏览器记住这个新的url

**302 Found**

临时性重定向，表示资源被分配了新的URI，希望用户能用新的URI访问。(ajax获取不到，见下面解释部分/HTTP1.1中302为Found，但也是一个别的地址)

**303 See Other**

**所请求的页面可在别的url下被找到。**
303与302有着相同的功能，303状态明确表示客户端应该采取GET方法获取资源。

**304 Not Modified**

表示客户端发了附带条件的请求时，服务器表示资源未改变，**客户端可以使用未过期的缓存。**

**307 Temporary Redirect**

临时重定向，与302不同的是，不会从POST变成GET。


**在HTTP权威指南中，HTTP1.0客户端发送POST请求时收到302响应不能自动重定向，而是需要向客户确认；而HTTP1.1客户端发送非GET、HEAD请求时收到302响应不能自动重定向，而是需要向客户确认，但是很多浏览器都是直接将POST重定向为GET处理。HTTP1.1中添加了303和307，303是将POST重定向为GET，而307则是POST重定向时请求客户端确认。**

**400 Bad Request**

请求报文存在语法错误，需要修改请求内容再重发请求。浏览器会像200一样对待。

**401 Unauthorized**

未认证的，需要通过有HTTP认证。如果之前有过一次请求，代表认证失败

**403 Forbidden**

表示请求资源的访问被服务器拒绝了，服务器没有必要返回拒绝的详细理由，想要说明的话，可以在实体的主体部分对原因给出描述。

**404 Not Found**

表明服务器上无法找到请求的资源。

**500 Internal Server Error**

服务器在执行请求的过程中发生了错误，可能是应用的bug或者临时的故障

**503 Service Unavailable**

服务器暂时处于超负载或者正要进行停机维护，暂时无法处理请求

## HTTP readystate
* 0-uninitialized：请求未初始化
* 1-loading：下载
* 2-loaded：下载完成
* 3-interactive：渲染
* 4-complete：所有数据已经准备好

#网络知识

## OSI层次模型

 * 物理层、数据链路层、网络层（IP）、传输层（TCP、UDP）、会话层、表示层和应用层（HTTP）。
　
 * socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。

## TCP三次握手，四次挥手
![3](images/三次握手.png)
为什么要三次握手: 为了防止已经失效的连接请求报文突然又传到了server端。

例：假如没有三次握手，如果client端发报文，但因为网络延迟而滞留，会被server端当成一个新的包，建立连接，但此时client并没有要建立连接的意思…然后server就会不断发包给client，client并不理睬，这样就造成了不必要的资源浪费。（这是发送第三次ACK的原因）

![4](images/四次挥手.png)

过程：

* TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送. **这表示主机1没有数据要发送给主机2**了；
* 服务器收到这个FIN，它发回一个ACK.**我“同意”你的关闭请求；**
* 服务器关闭客户端的连接，发送一个FIN给客户端. **主机2向主机1发送FIN报文段，请求关闭连接**
* 客户端发回ACK报文确认，并将确认序号设置为收到序号.**主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭**

之所以要有CLOSE_WAIT的状态，是因为server端有可能没有发送完所有数据，需要等待将所有未发送完的数据都送到client端后，
才能发送FIN，而不能一起发【因为那样相当于客户端又接到数据不处理就关闭】

# RESTful架构
一种互联网软件架构，结构清晰、符合标准、易于理解、扩展方便，核心是远程资源调用，Representational State Transfer**表现层状态转化**。http是无状态的（无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态），所以rest操作也是无状态的，不存在context约束，其目的是定义如何正确的使用web标准，优雅的使用HTTP特性。

每个URI代表一种资源
客户端和服务器之间传递这种资源的某种表现层
客户端通过4个HTTP动作：「get」获取资源、「post」新建/更新资源、「put」更新资源、「delete」删除资源来对服务器进行操作，实现表现层状态转化

# 前端页面优化
* 减少HTTP请求
* 使Ajax可缓存
* 避免重定向
* 减小cookie大小
* 将样式表放到页面顶部
* 将脚本放到页面底部
* 压缩javascript和css

server端：
* 使用CDN
* 添加Expires或者Cache-Control响应头
* 配置ETag

[**yahoo 35条**](http://www.cnblogs.com/lei2007/archive/2013/08/16/3262897.html)


#跨域技术 

## CORS
使用 XMLHttpRequest 和 Fetch 发起 HTTP 请求就必须遵守同源策略。

**同源策略**： 如果协议，端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。

跨域并非浏览器限制了发起跨站请求，而是跨站请求可以正常发起，但是返回结果被浏览器拦截了。

对那些会对服务器数据造成副作用的 HTTP 请求方法，标准强烈要求浏览器必须先以 OPTIONS 请求方式发送一个预请求(preflight request)，从而获知服务器端对跨源请求所支持 HTTP 方法。在确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。

使用CORS头来处理跨域： Access-Control-Allow-Origin: * 

### JSONP

用 script 标签加载其他域中的文件是不会有问题。

解决思路： 允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了

```js
function jsonp(url, params, callback) {
  const parsmQuery = [];
  Object.keys(params).forEach(key => {
    parsmQuery.push(`${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`);
  })
  
  // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
  let _url;
  _url = url + (parsmQuery.length > 0 ? `?${parsmQuery.join('&')}` : `?`);
  _url = _url + `&callback=callback2017`;

  console.log(_url);
  
  // 创建script标签，设置其属性
  const script = document.createElement('script');
  script.setAttribute('src', _url);
  script.type = "text/javascript";
  
  // 把script标签加入head，此时调用开始
  document.getElementsByTagName('head')[0].appendChild(script);

  window['callback2017'] = (res) => {
    callback(res);
  }
}

jsonp('http://music.163.com/api/user/playlist/', {
  uid: 40652589,
  limit: 1,
  offset: 0
}, function(data) {console.log(data)})
```

#算法题

## 设计一种算法可以求出 某个数字是否 在10亿个数中出现过

海量数据压缩: bitmap

## 统计一个数组出现频率最高的元素，给出那个元素以及出现的次数，要求考虑时间和空间复杂度

hashMap， 记录当前出现次数最多的元素。