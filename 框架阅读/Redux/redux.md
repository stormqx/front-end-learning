# redux

## 动机

### 动机一：管理持续变化的状态是困难的

如今前端开发SPA盛行，**我们管理着比以前多得多的状态**。 

这些状态包括:

* 来自服务器的响应
* 缓存的数据
* 前端组件之间的通信的状态
* 在本地产生还未持久化到服务器的状态
* UI相关的状态。比如路由信息，分页控制等等...

管理这种变化的状态是困难的。试想下这样一个场景：**如果一个model可以更新另外的model。当有一个view更新了一个model, 这个model会更改另外一个model。反过来，有可能会更新另外一个view.** 到某个临界点，你不再理解app发生了什么。因为你**失去了对state的控制(when, why, how)**。

> 当一个系统变得**不透明**和**不确定**。它就很难重现bug和添加新的features.


### 动机二：人类很难处理好的两个概念：可变(mutation)和异步(asynchonicity)

前端发展迅猛。各种新名词：乐观更新，服务器渲染（SSR），路由切换前获取数据等等。 我们发现我们管理起来比以往任何时候都要复杂。 这后面的原因我认为就是:**可变(mutation)和异步(asynchonicity)**.

所以react尝试着解决一些问题：**它在view层试着移除异步和直接操纵DOM。** 但是react实际上只是一个view层的框架，它把管理状态这件事交给你自己来处理。 *这就是Redux要做的事情： 让状态变化可预测。*	


## 三个原则

* **单一数据源**。 整个应用的state存储在一个store中的对象树🌲中。
* **状态是只读的**。 改变状态的唯一方法就是发送一个action，这个action描述了发生的行为。
* **通过纯函数来改变**。 通过pure reducer来解决。