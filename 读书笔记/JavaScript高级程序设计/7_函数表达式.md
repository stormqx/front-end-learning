# 函数表达式

**定义函数的方式有三种：**

1. 函数声明。特征：函数声明提升，即在执行代码之前会先读取函数声明。
2. 函数表达式
3. 箭头函数

**递归**： 递归调用函数可以使用`arguments.callee`来代替函数名，这种做法更保险一些。

```js
function factorial(num) {
  if(num <=1) {
    return 1;
  } else {
    return num * arguments.callee(num-1);
  }
}

var anotherFactorial = factorial;
factorial = null;
alert(anotherFactorial(4)) //使用arguments.callee，即使将factorial设置为null,也不会影响函数内部的执行过程。
```

## 闭包

**闭包是指有权访问另一个函数作用域中变量的函数。**

### 创建作用域链的细节
当某个函数被调用时，会创建一个执行环境(execution context)及相应的作用域链。然后使用`arguments`,`this`和其他命名参数来初始化函数的活动对象(activation object)。

每个执行环境都有一个表示变量的对象 --- **变量对象**。 全局环境的变量对象始终存在， 函数这种局部环境的变量对象，只在函数执行的过程中存在。**在创建函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的`[[scope]]`属性中。当调用函数时，会为函数创建一个执行环境，一个活动对象被创建病推入执行环境作用域链的前端。**

**作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。**

### 闭包的原理
在一个函数内部定义的函数**会将包含函数(即外部函数)的活动对象添加到它的作用域链中**。在内部函数返回时，它的作用域链被初始化为包含**外部函数活动对象**和**全局变量对象**。 且在外部函数执行完成后，其执行环境的作用域链会被销毁，但其活动对象不会销毁。这就造成了闭包。

只有当内部函数被销毁后，外部函数的活动对象才会被销毁。